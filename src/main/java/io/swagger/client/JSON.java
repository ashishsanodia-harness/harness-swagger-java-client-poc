/*
 * CD NextGen API Reference
 * This is the Open Api Spec 3 for the NextGen Manager. This is under active development. Beware of the breaking change with respect to the generated code stub  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * OpenAPI spec version: 3.0
 * Contact: contact@harness.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import io.gsonfire.GsonFireBuilder;
import io.gsonfire.PostProcessor;
import io.gsonfire.TypeSelector;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.internal.bind.util.ISO8601Utils;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import org.threeten.bp.LocalDate;
import org.threeten.bp.OffsetDateTime;
import org.threeten.bp.format.DateTimeFormatter;

import io.swagger.client.model.*;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.util.Date;
import java.util.Map;
import java.util.HashMap;

public class JSON {
    private Gson gson;
    private boolean isLenientOnJson = false;
    private DateTypeAdapter dateTypeAdapter = new DateTypeAdapter();
    private SqlDateTypeAdapter sqlDateTypeAdapter = new SqlDateTypeAdapter();
    private OffsetDateTimeTypeAdapter offsetDateTimeTypeAdapter = new OffsetDateTimeTypeAdapter();
    private LocalDateTypeAdapter localDateTypeAdapter = new LocalDateTypeAdapter();

    public static GsonBuilder createGson() {
        GsonFireBuilder fireBuilder = new GsonFireBuilder()
          .registerTypeSelector(FailureStrategyActionConfig.class, new TypeSelector<FailureStrategyActionConfig>() {
            @Override
            public Class<? extends FailureStrategyActionConfig> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends FailureStrategyActionConfig>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("AbortFailureActionConfig".toUpperCase(), AbortFailureActionConfig.class);
                    classByDiscriminatorValue.put("IgnoreFailureActionConfig".toUpperCase(), IgnoreFailureActionConfig.class);
                    classByDiscriminatorValue.put("ManualInterventionFailureActionConfig".toUpperCase(), ManualInterventionFailureActionConfig.class);
                    classByDiscriminatorValue.put("MarkAsSuccessFailureActionConfig".toUpperCase(), MarkAsSuccessFailureActionConfig.class);
                    classByDiscriminatorValue.put("RetryFailureActionConfig".toUpperCase(), RetryFailureActionConfig.class);
                    classByDiscriminatorValue.put("StageRollbackFailureActionConfig".toUpperCase(), StageRollbackFailureActionConfig.class);
                    classByDiscriminatorValue.put("StepGroupFailureActionConfig".toUpperCase(), StepGroupFailureActionConfig.class);
                    classByDiscriminatorValue.put("FailureStrategyActionConfig".toUpperCase(), FailureStrategyActionConfig.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(FailureStrategyActionConfig.class, new PostProcessor<FailureStrategyActionConfig>() {
              @Override
              public void postDeserialize(FailureStrategyActionConfig result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, FailureStrategyActionConfig src, Gson gson) {
                  Map<Class<? extends FailureStrategyActionConfig>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(AbortFailureActionConfig.class, "AbortFailureActionConfig");
                      discriminatorValueByClass.put(IgnoreFailureActionConfig.class, "IgnoreFailureActionConfig");
                      discriminatorValueByClass.put(ManualInterventionFailureActionConfig.class, "ManualInterventionFailureActionConfig");
                      discriminatorValueByClass.put(MarkAsSuccessFailureActionConfig.class, "MarkAsSuccessFailureActionConfig");
                      discriminatorValueByClass.put(RetryFailureActionConfig.class, "RetryFailureActionConfig");
                      discriminatorValueByClass.put(StageRollbackFailureActionConfig.class, "StageRollbackFailureActionConfig");
                      discriminatorValueByClass.put(StepGroupFailureActionConfig.class, "StepGroupFailureActionConfig");
                      discriminatorValueByClass.put(FailureStrategyActionConfig.class, "FailureStrategyActionConfig");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(AuditEventData.class, new TypeSelector<AuditEventData>() {
            @Override
            public Class<? extends AuditEventData> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends AuditEventData>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("AddCollaboratorAuditEventData".toUpperCase(), AddCollaboratorAuditEventData.class);
                    classByDiscriminatorValue.put("TemplateEventData".toUpperCase(), TemplateEventData.class);
                    classByDiscriminatorValue.put("UserInvitationAuditEventData".toUpperCase(), UserInvitationAuditEventData.class);
                    classByDiscriminatorValue.put("UserInviteAuditEventData".toUpperCase(), UserInviteAuditEventData.class);
                    classByDiscriminatorValue.put("UserMembershipAuditEventData".toUpperCase(), UserMembershipAuditEventData.class);
                    classByDiscriminatorValue.put("AuditEventData".toUpperCase(), AuditEventData.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(AuditEventData.class, new PostProcessor<AuditEventData>() {
              @Override
              public void postDeserialize(AuditEventData result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, AuditEventData src, Gson gson) {
                  Map<Class<? extends AuditEventData>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(AddCollaboratorAuditEventData.class, "AddCollaboratorAuditEventData");
                      discriminatorValueByClass.put(TemplateEventData.class, "TemplateEventData");
                      discriminatorValueByClass.put(UserInvitationAuditEventData.class, "UserInvitationAuditEventData");
                      discriminatorValueByClass.put(UserInviteAuditEventData.class, "UserInviteAuditEventData");
                      discriminatorValueByClass.put(UserMembershipAuditEventData.class, "UserMembershipAuditEventData");
                      discriminatorValueByClass.put(AuditEventData.class, "AuditEventData");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(PatchOperation.class, new TypeSelector<PatchOperation>() {
            @Override
            public Class<? extends PatchOperation> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends PatchOperation>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("AddOperation".toUpperCase(), AddOperation.class);
                    classByDiscriminatorValue.put("OktaAddOperation".toUpperCase(), OktaAddOperation.class);
                    classByDiscriminatorValue.put("OktaRemoveOperation".toUpperCase(), OktaRemoveOperation.class);
                    classByDiscriminatorValue.put("OktaReplaceOperation".toUpperCase(), OktaReplaceOperation.class);
                    classByDiscriminatorValue.put("RemoveOperation".toUpperCase(), RemoveOperation.class);
                    classByDiscriminatorValue.put("ReplaceOperation".toUpperCase(), ReplaceOperation.class);
                    classByDiscriminatorValue.put("PatchOperation".toUpperCase(), PatchOperation.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "op"));
            }
          })
          .registerPostProcessor(PatchOperation.class, new PostProcessor<PatchOperation>() {
              @Override
              public void postDeserialize(PatchOperation result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, PatchOperation src, Gson gson) {
                  Map<Class<? extends PatchOperation>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(AddOperation.class, "AddOperation");
                      discriminatorValueByClass.put(OktaAddOperation.class, "OktaAddOperation");
                      discriminatorValueByClass.put(OktaRemoveOperation.class, "OktaRemoveOperation");
                      discriminatorValueByClass.put(OktaReplaceOperation.class, "OktaReplaceOperation");
                      discriminatorValueByClass.put(RemoveOperation.class, "RemoveOperation");
                      discriminatorValueByClass.put(ReplaceOperation.class, "ReplaceOperation");
                      discriminatorValueByClass.put(PatchOperation.class, "PatchOperation");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("op"))
                      {
                          ((JsonObject) result).addProperty("op", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(Pagination.class, new TypeSelector<Pagination>() {
            @Override
            public Class<? extends Pagination> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends Pagination>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("ApiKeys".toUpperCase(), ApiKeys.class);
                    classByDiscriminatorValue.put("Features".toUpperCase(), Features.class);
                    classByDiscriminatorValue.put("FlagBasicInfos".toUpperCase(), FlagBasicInfos.class);
                    classByDiscriminatorValue.put("Segments".toUpperCase(), Segments.class);
                    classByDiscriminatorValue.put("Targets".toUpperCase(), Targets.class);
                    classByDiscriminatorValue.put("Pagination".toUpperCase(), Pagination.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(Pagination.class, new PostProcessor<Pagination>() {
              @Override
              public void postDeserialize(Pagination result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, Pagination src, Gson gson) {
                  Map<Class<? extends Pagination>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(ApiKeys.class, "ApiKeys");
                      discriminatorValueByClass.put(Features.class, "Features");
                      discriminatorValueByClass.put(FlagBasicInfos.class, "FlagBasicInfos");
                      discriminatorValueByClass.put(Segments.class, "Segments");
                      discriminatorValueByClass.put(Targets.class, "Targets");
                      discriminatorValueByClass.put(Pagination.class, "Pagination");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(ConnectorConfig.class, new TypeSelector<ConnectorConfig>() {
            @Override
            public Class<? extends ConnectorConfig> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends ConnectorConfig>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("AppDynamicsConnectorDTO".toUpperCase(), AppDynamicsConnectorDTO.class);
                    classByDiscriminatorValue.put("ArtifactoryConnector".toUpperCase(), ArtifactoryConnector.class);
                    classByDiscriminatorValue.put("AwsCodeCommitConnector".toUpperCase(), AwsCodeCommitConnector.class);
                    classByDiscriminatorValue.put("AwsConnector".toUpperCase(), AwsConnector.class);
                    classByDiscriminatorValue.put("AwsKmsConnector".toUpperCase(), AwsKmsConnector.class);
                    classByDiscriminatorValue.put("AwsSecretManager".toUpperCase(), AwsSecretManager.class);
                    classByDiscriminatorValue.put("AzureKeyVaultConnector".toUpperCase(), AzureKeyVaultConnector.class);
                    classByDiscriminatorValue.put("BitbucketConnector".toUpperCase(), BitbucketConnector.class);
                    classByDiscriminatorValue.put("CEAwsConnector".toUpperCase(), CEAwsConnector.class);
                    classByDiscriminatorValue.put("CEAzureConnector".toUpperCase(), CEAzureConnector.class);
                    classByDiscriminatorValue.put("CEKubernetesClusterConfigDTO".toUpperCase(), CEKubernetesClusterConfigDTO.class);
                    classByDiscriminatorValue.put("CustomHealthConnectorDTO".toUpperCase(), CustomHealthConnectorDTO.class);
                    classByDiscriminatorValue.put("DatadogConnectorDTO".toUpperCase(), DatadogConnectorDTO.class);
                    classByDiscriminatorValue.put("DockerConnector".toUpperCase(), DockerConnector.class);
                    classByDiscriminatorValue.put("DynatraceConnectorDTO".toUpperCase(), DynatraceConnectorDTO.class);
                    classByDiscriminatorValue.put("ErrorTrackingConnectorDTO".toUpperCase(), ErrorTrackingConnectorDTO.class);
                    classByDiscriminatorValue.put("GcpCloudCostConnectorDTO".toUpperCase(), GcpCloudCostConnectorDTO.class);
                    classByDiscriminatorValue.put("GcpConnector".toUpperCase(), GcpConnector.class);
                    classByDiscriminatorValue.put("GcpKmsConnector".toUpperCase(), GcpKmsConnector.class);
                    classByDiscriminatorValue.put("GitConfig".toUpperCase(), GitConfig.class);
                    classByDiscriminatorValue.put("GithubConnector".toUpperCase(), GithubConnector.class);
                    classByDiscriminatorValue.put("GitlabConnector".toUpperCase(), GitlabConnector.class);
                    classByDiscriminatorValue.put("HttpHelmConnector".toUpperCase(), HttpHelmConnector.class);
                    classByDiscriminatorValue.put("JiraConnector".toUpperCase(), JiraConnector.class);
                    classByDiscriminatorValue.put("KubernetesClusterConfig".toUpperCase(), KubernetesClusterConfig.class);
                    classByDiscriminatorValue.put("LocalConnector".toUpperCase(), LocalConnector.class);
                    classByDiscriminatorValue.put("NewRelicConnectorDTO".toUpperCase(), NewRelicConnectorDTO.class);
                    classByDiscriminatorValue.put("NexusConnector".toUpperCase(), NexusConnector.class);
                    classByDiscriminatorValue.put("PagerDutyConnectorDTO".toUpperCase(), PagerDutyConnectorDTO.class);
                    classByDiscriminatorValue.put("PrometheusConnectorDTO".toUpperCase(), PrometheusConnectorDTO.class);
                    classByDiscriminatorValue.put("ServiceNowConnectorDTO".toUpperCase(), ServiceNowConnectorDTO.class);
                    classByDiscriminatorValue.put("SplunkConnector".toUpperCase(), SplunkConnector.class);
                    classByDiscriminatorValue.put("SumoLogicConnectorDTO".toUpperCase(), SumoLogicConnectorDTO.class);
                    classByDiscriminatorValue.put("VaultConnector".toUpperCase(), VaultConnector.class);
                    classByDiscriminatorValue.put("ConnectorConfig".toUpperCase(), ConnectorConfig.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(ConnectorConfig.class, new PostProcessor<ConnectorConfig>() {
              @Override
              public void postDeserialize(ConnectorConfig result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, ConnectorConfig src, Gson gson) {
                  Map<Class<? extends ConnectorConfig>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(AppDynamicsConnectorDTO.class, "AppDynamicsConnectorDTO");
                      discriminatorValueByClass.put(ArtifactoryConnector.class, "ArtifactoryConnector");
                      discriminatorValueByClass.put(AwsCodeCommitConnector.class, "AwsCodeCommitConnector");
                      discriminatorValueByClass.put(AwsConnector.class, "AwsConnector");
                      discriminatorValueByClass.put(AwsKmsConnector.class, "AwsKmsConnector");
                      discriminatorValueByClass.put(AwsSecretManager.class, "AwsSecretManager");
                      discriminatorValueByClass.put(AzureKeyVaultConnector.class, "AzureKeyVaultConnector");
                      discriminatorValueByClass.put(BitbucketConnector.class, "BitbucketConnector");
                      discriminatorValueByClass.put(CEAwsConnector.class, "CEAwsConnector");
                      discriminatorValueByClass.put(CEAzureConnector.class, "CEAzureConnector");
                      discriminatorValueByClass.put(CEKubernetesClusterConfigDTO.class, "CEKubernetesClusterConfigDTO");
                      discriminatorValueByClass.put(CustomHealthConnectorDTO.class, "CustomHealthConnectorDTO");
                      discriminatorValueByClass.put(DatadogConnectorDTO.class, "DatadogConnectorDTO");
                      discriminatorValueByClass.put(DockerConnector.class, "DockerConnector");
                      discriminatorValueByClass.put(DynatraceConnectorDTO.class, "DynatraceConnectorDTO");
                      discriminatorValueByClass.put(ErrorTrackingConnectorDTO.class, "ErrorTrackingConnectorDTO");
                      discriminatorValueByClass.put(GcpCloudCostConnectorDTO.class, "GcpCloudCostConnectorDTO");
                      discriminatorValueByClass.put(GcpConnector.class, "GcpConnector");
                      discriminatorValueByClass.put(GcpKmsConnector.class, "GcpKmsConnector");
                      discriminatorValueByClass.put(GitConfig.class, "GitConfig");
                      discriminatorValueByClass.put(GithubConnector.class, "GithubConnector");
                      discriminatorValueByClass.put(GitlabConnector.class, "GitlabConnector");
                      discriminatorValueByClass.put(HttpHelmConnector.class, "HttpHelmConnector");
                      discriminatorValueByClass.put(JiraConnector.class, "JiraConnector");
                      discriminatorValueByClass.put(KubernetesClusterConfig.class, "KubernetesClusterConfig");
                      discriminatorValueByClass.put(LocalConnector.class, "LocalConnector");
                      discriminatorValueByClass.put(NewRelicConnectorDTO.class, "NewRelicConnectorDTO");
                      discriminatorValueByClass.put(NexusConnector.class, "NexusConnector");
                      discriminatorValueByClass.put(PagerDutyConnectorDTO.class, "PagerDutyConnectorDTO");
                      discriminatorValueByClass.put(PrometheusConnectorDTO.class, "PrometheusConnectorDTO");
                      discriminatorValueByClass.put(ServiceNowConnectorDTO.class, "ServiceNowConnectorDTO");
                      discriminatorValueByClass.put(SplunkConnector.class, "SplunkConnector");
                      discriminatorValueByClass.put(SumoLogicConnectorDTO.class, "SumoLogicConnectorDTO");
                      discriminatorValueByClass.put(VaultConnector.class, "VaultConnector");
                      discriminatorValueByClass.put(ConnectorConfig.class, "ConnectorConfig");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(BudgetScope.class, new TypeSelector<BudgetScope>() {
            @Override
            public Class<? extends BudgetScope> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends BudgetScope>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("ApplicationBudgetScope".toUpperCase(), ApplicationBudgetScope.class);
                    classByDiscriminatorValue.put("ClusterBudgetScope".toUpperCase(), ClusterBudgetScope.class);
                    classByDiscriminatorValue.put("PerspectiveBudgetScope".toUpperCase(), PerspectiveBudgetScope.class);
                    classByDiscriminatorValue.put("BudgetScope".toUpperCase(), BudgetScope.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(BudgetScope.class, new PostProcessor<BudgetScope>() {
              @Override
              public void postDeserialize(BudgetScope result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, BudgetScope src, Gson gson) {
                  Map<Class<? extends BudgetScope>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(ApplicationBudgetScope.class, "ApplicationBudgetScope");
                      discriminatorValueByClass.put(ClusterBudgetScope.class, "ClusterBudgetScope");
                      discriminatorValueByClass.put(PerspectiveBudgetScope.class, "PerspectiveBudgetScope");
                      discriminatorValueByClass.put(BudgetScope.class, "BudgetScope");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(ArtifactoryAuthCredentials.class, new TypeSelector<ArtifactoryAuthCredentials>() {
            @Override
            public Class<? extends ArtifactoryAuthCredentials> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends ArtifactoryAuthCredentials>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("ArtifactoryUsernamePasswordAuth".toUpperCase(), ArtifactoryUsernamePasswordAuth.class);
                    classByDiscriminatorValue.put("ArtifactoryAuthCredentials".toUpperCase(), ArtifactoryAuthCredentials.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(ArtifactoryAuthCredentials.class, new PostProcessor<ArtifactoryAuthCredentials>() {
              @Override
              public void postDeserialize(ArtifactoryAuthCredentials result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, ArtifactoryAuthCredentials src, Gson gson) {
                  Map<Class<? extends ArtifactoryAuthCredentials>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(ArtifactoryUsernamePasswordAuth.class, "ArtifactoryUsernamePasswordAuth");
                      discriminatorValueByClass.put(ArtifactoryAuthCredentials.class, "ArtifactoryAuthCredentials");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(RestrictionMetadata.class, new TypeSelector<RestrictionMetadata>() {
            @Override
            public Class<? extends RestrictionMetadata> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends RestrictionMetadata>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("AvailabilityRestrictionMetadata".toUpperCase(), AvailabilityRestrictionMetadata.class);
                    classByDiscriminatorValue.put("CustomRestrictionMetadata".toUpperCase(), CustomRestrictionMetadata.class);
                    classByDiscriminatorValue.put("DurationRestrictionMetadata".toUpperCase(), DurationRestrictionMetadata.class);
                    classByDiscriminatorValue.put("LicenseRateLimitRestrictionMetadataDTO".toUpperCase(), LicenseRateLimitRestrictionMetadataDTO.class);
                    classByDiscriminatorValue.put("LicenseStaticLimitRestrictionMetadataDTO".toUpperCase(), LicenseStaticLimitRestrictionMetadataDTO.class);
                    classByDiscriminatorValue.put("RateLimitRestrictionMetadata".toUpperCase(), RateLimitRestrictionMetadata.class);
                    classByDiscriminatorValue.put("StaticLimitRestrictionMetadata".toUpperCase(), StaticLimitRestrictionMetadata.class);
                    classByDiscriminatorValue.put("RestrictionMetadata".toUpperCase(), RestrictionMetadata.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "restrictionType"));
            }
          })
          .registerPostProcessor(RestrictionMetadata.class, new PostProcessor<RestrictionMetadata>() {
              @Override
              public void postDeserialize(RestrictionMetadata result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, RestrictionMetadata src, Gson gson) {
                  Map<Class<? extends RestrictionMetadata>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(AvailabilityRestrictionMetadata.class, "AvailabilityRestrictionMetadata");
                      discriminatorValueByClass.put(CustomRestrictionMetadata.class, "CustomRestrictionMetadata");
                      discriminatorValueByClass.put(DurationRestrictionMetadata.class, "DurationRestrictionMetadata");
                      discriminatorValueByClass.put(LicenseRateLimitRestrictionMetadataDTO.class, "LicenseRateLimitRestrictionMetadataDTO");
                      discriminatorValueByClass.put(LicenseStaticLimitRestrictionMetadataDTO.class, "LicenseStaticLimitRestrictionMetadataDTO");
                      discriminatorValueByClass.put(RateLimitRestrictionMetadata.class, "RateLimitRestrictionMetadata");
                      discriminatorValueByClass.put(StaticLimitRestrictionMetadata.class, "StaticLimitRestrictionMetadata");
                      discriminatorValueByClass.put(RestrictionMetadata.class, "RestrictionMetadata");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("restrictionType"))
                      {
                          ((JsonObject) result).addProperty("restrictionType", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(AwsCodeCommitCredentials.class, new TypeSelector<AwsCodeCommitCredentials>() {
            @Override
            public Class<? extends AwsCodeCommitCredentials> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends AwsCodeCommitCredentials>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("AwsCodeCommitHttpsCredentials".toUpperCase(), AwsCodeCommitHttpsCredentials.class);
                    classByDiscriminatorValue.put("AwsCodeCommitCredentials".toUpperCase(), AwsCodeCommitCredentials.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(AwsCodeCommitCredentials.class, new PostProcessor<AwsCodeCommitCredentials>() {
              @Override
              public void postDeserialize(AwsCodeCommitCredentials result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, AwsCodeCommitCredentials src, Gson gson) {
                  Map<Class<? extends AwsCodeCommitCredentials>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(AwsCodeCommitHttpsCredentials.class, "AwsCodeCommitHttpsCredentials");
                      discriminatorValueByClass.put(AwsCodeCommitCredentials.class, "AwsCodeCommitCredentials");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(AwsCodeCommitHttpsCredentialsSpec.class, new TypeSelector<AwsCodeCommitHttpsCredentialsSpec>() {
            @Override
            public Class<? extends AwsCodeCommitHttpsCredentialsSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends AwsCodeCommitHttpsCredentialsSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("AwsCodeCommitSecretKeyAccessKey".toUpperCase(), AwsCodeCommitSecretKeyAccessKey.class);
                    classByDiscriminatorValue.put("AwsCodeCommitHttpsCredentialsSpec".toUpperCase(), AwsCodeCommitHttpsCredentialsSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(AwsCodeCommitHttpsCredentialsSpec.class, new PostProcessor<AwsCodeCommitHttpsCredentialsSpec>() {
              @Override
              public void postDeserialize(AwsCodeCommitHttpsCredentialsSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, AwsCodeCommitHttpsCredentialsSpec src, Gson gson) {
                  Map<Class<? extends AwsCodeCommitHttpsCredentialsSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(AwsCodeCommitSecretKeyAccessKey.class, "AwsCodeCommitSecretKeyAccessKey");
                      discriminatorValueByClass.put(AwsCodeCommitHttpsCredentialsSpec.class, "AwsCodeCommitHttpsCredentialsSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(AwsKmsCredentialSpec.class, new TypeSelector<AwsKmsCredentialSpec>() {
            @Override
            public Class<? extends AwsKmsCredentialSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends AwsKmsCredentialSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("AwsKmsCredentialSpecAssumeIAM".toUpperCase(), AwsKmsCredentialSpecAssumeIAM.class);
                    classByDiscriminatorValue.put("AwsKmsCredentialSpecAssumeSTS".toUpperCase(), AwsKmsCredentialSpecAssumeSTS.class);
                    classByDiscriminatorValue.put("AwsKmsCredentialSpecManualConfig".toUpperCase(), AwsKmsCredentialSpecManualConfig.class);
                    classByDiscriminatorValue.put("AwsKmsCredentialSpec".toUpperCase(), AwsKmsCredentialSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(AwsKmsCredentialSpec.class, new PostProcessor<AwsKmsCredentialSpec>() {
              @Override
              public void postDeserialize(AwsKmsCredentialSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, AwsKmsCredentialSpec src, Gson gson) {
                  Map<Class<? extends AwsKmsCredentialSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(AwsKmsCredentialSpecAssumeIAM.class, "AwsKmsCredentialSpecAssumeIAM");
                      discriminatorValueByClass.put(AwsKmsCredentialSpecAssumeSTS.class, "AwsKmsCredentialSpecAssumeSTS");
                      discriminatorValueByClass.put(AwsKmsCredentialSpecManualConfig.class, "AwsKmsCredentialSpecManualConfig");
                      discriminatorValueByClass.put(AwsKmsCredentialSpec.class, "AwsKmsCredentialSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(AwsCredentialSpec.class, new TypeSelector<AwsCredentialSpec>() {
            @Override
            public Class<? extends AwsCredentialSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends AwsCredentialSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("AwsManualConfigSpec".toUpperCase(), AwsManualConfigSpec.class);
                    classByDiscriminatorValue.put("AwsCredentialSpec".toUpperCase(), AwsCredentialSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(AwsCredentialSpec.class, new PostProcessor<AwsCredentialSpec>() {
              @Override
              public void postDeserialize(AwsCredentialSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, AwsCredentialSpec src, Gson gson) {
                  Map<Class<? extends AwsCredentialSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(AwsManualConfigSpec.class, "AwsManualConfigSpec");
                      discriminatorValueByClass.put(AwsCredentialSpec.class, "AwsCredentialSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(AwsSecretManagerCredentialSpec.class, new TypeSelector<AwsSecretManagerCredentialSpec>() {
            @Override
            public Class<? extends AwsSecretManagerCredentialSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends AwsSecretManagerCredentialSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("AwsSMCredentialSpecAssumeIAM".toUpperCase(), AwsSMCredentialSpecAssumeIAM.class);
                    classByDiscriminatorValue.put("AwsSMCredentialSpecAssumeSTS".toUpperCase(), AwsSMCredentialSpecAssumeSTS.class);
                    classByDiscriminatorValue.put("AwsSMCredentialSpecManualConfig".toUpperCase(), AwsSMCredentialSpecManualConfig.class);
                    classByDiscriminatorValue.put("AwsSecretManagerCredentialSpec".toUpperCase(), AwsSecretManagerCredentialSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(AwsSecretManagerCredentialSpec.class, new PostProcessor<AwsSecretManagerCredentialSpec>() {
              @Override
              public void postDeserialize(AwsSecretManagerCredentialSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, AwsSecretManagerCredentialSpec src, Gson gson) {
                  Map<Class<? extends AwsSecretManagerCredentialSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(AwsSMCredentialSpecAssumeIAM.class, "AwsSMCredentialSpecAssumeIAM");
                      discriminatorValueByClass.put(AwsSMCredentialSpecAssumeSTS.class, "AwsSMCredentialSpecAssumeSTS");
                      discriminatorValueByClass.put(AwsSMCredentialSpecManualConfig.class, "AwsSMCredentialSpecManualConfig");
                      discriminatorValueByClass.put(AwsSecretManagerCredentialSpec.class, "AwsSecretManagerCredentialSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(BitbucketCredentials.class, new TypeSelector<BitbucketCredentials>() {
            @Override
            public Class<? extends BitbucketCredentials> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends BitbucketCredentials>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("BitbucketHttpCredentials".toUpperCase(), BitbucketHttpCredentials.class);
                    classByDiscriminatorValue.put("BitbucketSshCredentials".toUpperCase(), BitbucketSshCredentials.class);
                    classByDiscriminatorValue.put("BitbucketCredentials".toUpperCase(), BitbucketCredentials.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(BitbucketCredentials.class, new PostProcessor<BitbucketCredentials>() {
              @Override
              public void postDeserialize(BitbucketCredentials result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, BitbucketCredentials src, Gson gson) {
                  Map<Class<? extends BitbucketCredentials>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(BitbucketHttpCredentials.class, "BitbucketHttpCredentials");
                      discriminatorValueByClass.put(BitbucketSshCredentials.class, "BitbucketSshCredentials");
                      discriminatorValueByClass.put(BitbucketCredentials.class, "BitbucketCredentials");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(BitbucketHttpCredentialsSpec.class, new TypeSelector<BitbucketHttpCredentialsSpec>() {
            @Override
            public Class<? extends BitbucketHttpCredentialsSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends BitbucketHttpCredentialsSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("BitbucketUsernamePassword".toUpperCase(), BitbucketUsernamePassword.class);
                    classByDiscriminatorValue.put("BitbucketHttpCredentialsSpec".toUpperCase(), BitbucketHttpCredentialsSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(BitbucketHttpCredentialsSpec.class, new PostProcessor<BitbucketHttpCredentialsSpec>() {
              @Override
              public void postDeserialize(BitbucketHttpCredentialsSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, BitbucketHttpCredentialsSpec src, Gson gson) {
                  Map<Class<? extends BitbucketHttpCredentialsSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(BitbucketUsernamePassword.class, "BitbucketUsernamePassword");
                      discriminatorValueByClass.put(BitbucketHttpCredentialsSpec.class, "BitbucketHttpCredentialsSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(BitbucketApiAccess.class, new TypeSelector<BitbucketApiAccess>() {
            @Override
            public Class<? extends BitbucketApiAccess> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends BitbucketApiAccess>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("BitbucketUsernameTokenApiAccess".toUpperCase(), BitbucketUsernameTokenApiAccess.class);
                    classByDiscriminatorValue.put("BitbucketApiAccess".toUpperCase(), BitbucketApiAccess.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(BitbucketApiAccess.class, new PostProcessor<BitbucketApiAccess>() {
              @Override
              public void postDeserialize(BitbucketApiAccess result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, BitbucketApiAccess src, Gson gson) {
                  Map<Class<? extends BitbucketApiAccess>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(BitbucketUsernameTokenApiAccess.class, "BitbucketUsernameTokenApiAccess");
                      discriminatorValueByClass.put(BitbucketApiAccess.class, "BitbucketApiAccess");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(LicensesWithSummary.class, new TypeSelector<LicensesWithSummary>() {
            @Override
            public Class<? extends LicensesWithSummary> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends LicensesWithSummary>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("CDLicenseSummary".toUpperCase(), CDLicenseSummary.class);
                    classByDiscriminatorValue.put("CELicenseSummary".toUpperCase(), CELicenseSummary.class);
                    classByDiscriminatorValue.put("CFLicenseSummary".toUpperCase(), CFLicenseSummary.class);
                    classByDiscriminatorValue.put("CILicenseSummary".toUpperCase(), CILicenseSummary.class);
                    classByDiscriminatorValue.put("CVLicenseSummary".toUpperCase(), CVLicenseSummary.class);
                    classByDiscriminatorValue.put("LicensesWithSummary".toUpperCase(), LicensesWithSummary.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "moduleType"));
            }
          })
          .registerPostProcessor(LicensesWithSummary.class, new PostProcessor<LicensesWithSummary>() {
              @Override
              public void postDeserialize(LicensesWithSummary result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, LicensesWithSummary src, Gson gson) {
                  Map<Class<? extends LicensesWithSummary>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(CDLicenseSummary.class, "CDLicenseSummary");
                      discriminatorValueByClass.put(CELicenseSummary.class, "CELicenseSummary");
                      discriminatorValueByClass.put(CFLicenseSummary.class, "CFLicenseSummary");
                      discriminatorValueByClass.put(CILicenseSummary.class, "CILicenseSummary");
                      discriminatorValueByClass.put(CVLicenseSummary.class, "CVLicenseSummary");
                      discriminatorValueByClass.put(LicensesWithSummary.class, "LicensesWithSummary");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("moduleType"))
                      {
                          ((JsonObject) result).addProperty("moduleType", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(ModuleLicense.class, new TypeSelector<ModuleLicense>() {
            @Override
            public Class<? extends ModuleLicense> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends ModuleLicense>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("CDModuleLicense".toUpperCase(), CDModuleLicense.class);
                    classByDiscriminatorValue.put("CEModuleLicense".toUpperCase(), CEModuleLicense.class);
                    classByDiscriminatorValue.put("CFModuleLicense".toUpperCase(), CFModuleLicense.class);
                    classByDiscriminatorValue.put("CIModuleLicense".toUpperCase(), CIModuleLicense.class);
                    classByDiscriminatorValue.put("CVModuleLicense".toUpperCase(), CVModuleLicense.class);
                    classByDiscriminatorValue.put("ModuleLicense".toUpperCase(), ModuleLicense.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "moduleType"));
            }
          })
          .registerPostProcessor(ModuleLicense.class, new PostProcessor<ModuleLicense>() {
              @Override
              public void postDeserialize(ModuleLicense result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, ModuleLicense src, Gson gson) {
                  Map<Class<? extends ModuleLicense>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(CDModuleLicense.class, "CDModuleLicense");
                      discriminatorValueByClass.put(CEModuleLicense.class, "CEModuleLicense");
                      discriminatorValueByClass.put(CFModuleLicense.class, "CFModuleLicense");
                      discriminatorValueByClass.put(CIModuleLicense.class, "CIModuleLicense");
                      discriminatorValueByClass.put(CVModuleLicense.class, "CVModuleLicense");
                      discriminatorValueByClass.put(ModuleLicense.class, "ModuleLicense");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("moduleType"))
                      {
                          ((JsonObject) result).addProperty("moduleType", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(DockerAuthCredentials.class, new TypeSelector<DockerAuthCredentials>() {
            @Override
            public Class<? extends DockerAuthCredentials> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends DockerAuthCredentials>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("DockerUserNamePassword".toUpperCase(), DockerUserNamePassword.class);
                    classByDiscriminatorValue.put("DockerAuthCredentials".toUpperCase(), DockerAuthCredentials.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(DockerAuthCredentials.class, new PostProcessor<DockerAuthCredentials>() {
              @Override
              public void postDeserialize(DockerAuthCredentials result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, DockerAuthCredentials src, Gson gson) {
                  Map<Class<? extends DockerAuthCredentials>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(DockerUserNamePassword.class, "DockerUserNamePassword");
                      discriminatorValueByClass.put(DockerAuthCredentials.class, "DockerAuthCredentials");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(ResourceSelector.class, new TypeSelector<ResourceSelector>() {
            @Override
            public Class<? extends ResourceSelector> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends ResourceSelector>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("DynamicResourceSelector".toUpperCase(), DynamicResourceSelector.class);
                    classByDiscriminatorValue.put("ResourceSelectorByScope".toUpperCase(), ResourceSelectorByScope.class);
                    classByDiscriminatorValue.put("StaticResourceSelector".toUpperCase(), StaticResourceSelector.class);
                    classByDiscriminatorValue.put("ResourceSelector".toUpperCase(), ResourceSelector.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(ResourceSelector.class, new PostProcessor<ResourceSelector>() {
              @Override
              public void postDeserialize(ResourceSelector result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, ResourceSelector src, Gson gson) {
                  Map<Class<? extends ResourceSelector>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(DynamicResourceSelector.class, "DynamicResourceSelector");
                      discriminatorValueByClass.put(ResourceSelectorByScope.class, "ResourceSelectorByScope");
                      discriminatorValueByClass.put(StaticResourceSelector.class, "StaticResourceSelector");
                      discriminatorValueByClass.put(ResourceSelector.class, "ResourceSelector");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(NotificationSettingConfigDTO.class, new TypeSelector<NotificationSettingConfigDTO>() {
            @Override
            public Class<? extends NotificationSettingConfigDTO> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends NotificationSettingConfigDTO>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("EmailConfigDTO".toUpperCase(), EmailConfigDTO.class);
                    classByDiscriminatorValue.put("MicrosoftTeamsConfigDTO".toUpperCase(), MicrosoftTeamsConfigDTO.class);
                    classByDiscriminatorValue.put("PagerDutyConfigDTO".toUpperCase(), PagerDutyConfigDTO.class);
                    classByDiscriminatorValue.put("SlackConfigDTO".toUpperCase(), SlackConfigDTO.class);
                    classByDiscriminatorValue.put("NotificationSettingConfigDTO".toUpperCase(), NotificationSettingConfigDTO.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(NotificationSettingConfigDTO.class, new PostProcessor<NotificationSettingConfigDTO>() {
              @Override
              public void postDeserialize(NotificationSettingConfigDTO result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, NotificationSettingConfigDTO src, Gson gson) {
                  Map<Class<? extends NotificationSettingConfigDTO>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(EmailConfigDTO.class, "EmailConfigDTO");
                      discriminatorValueByClass.put(MicrosoftTeamsConfigDTO.class, "MicrosoftTeamsConfigDTO");
                      discriminatorValueByClass.put(PagerDutyConfigDTO.class, "PagerDutyConfigDTO");
                      discriminatorValueByClass.put(SlackConfigDTO.class, "SlackConfigDTO");
                      discriminatorValueByClass.put(NotificationSettingConfigDTO.class, "NotificationSettingConfigDTO");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(GcpCredentialSpec.class, new TypeSelector<GcpCredentialSpec>() {
            @Override
            public Class<? extends GcpCredentialSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends GcpCredentialSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("GcpManualDetails".toUpperCase(), GcpManualDetails.class);
                    classByDiscriminatorValue.put("GcpCredentialSpec".toUpperCase(), GcpCredentialSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(GcpCredentialSpec.class, new PostProcessor<GcpCredentialSpec>() {
              @Override
              public void postDeserialize(GcpCredentialSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, GcpCredentialSpec src, Gson gson) {
                  Map<Class<? extends GcpCredentialSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(GcpManualDetails.class, "GcpManualDetails");
                      discriminatorValueByClass.put(GcpCredentialSpec.class, "GcpCredentialSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(GitAuthentication.class, new TypeSelector<GitAuthentication>() {
            @Override
            public Class<? extends GitAuthentication> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends GitAuthentication>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("GitHTTPAuthenticationDTO".toUpperCase(), GitHTTPAuthenticationDTO.class);
                    classByDiscriminatorValue.put("GitSSHAuthentication".toUpperCase(), GitSSHAuthentication.class);
                    classByDiscriminatorValue.put("GitAuthentication".toUpperCase(), GitAuthentication.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(GitAuthentication.class, new PostProcessor<GitAuthentication>() {
              @Override
              public void postDeserialize(GitAuthentication result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, GitAuthentication src, Gson gson) {
                  Map<Class<? extends GitAuthentication>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(GitHTTPAuthenticationDTO.class, "GitHTTPAuthenticationDTO");
                      discriminatorValueByClass.put(GitSSHAuthentication.class, "GitSSHAuthentication");
                      discriminatorValueByClass.put(GitAuthentication.class, "GitAuthentication");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(GithubApiAccessSpec.class, new TypeSelector<GithubApiAccessSpec>() {
            @Override
            public Class<? extends GithubApiAccessSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends GithubApiAccessSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("GithubAppSpec".toUpperCase(), GithubAppSpec.class);
                    classByDiscriminatorValue.put("GithubTokenSpec".toUpperCase(), GithubTokenSpec.class);
                    classByDiscriminatorValue.put("GithubApiAccessSpec".toUpperCase(), GithubApiAccessSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(GithubApiAccessSpec.class, new PostProcessor<GithubApiAccessSpec>() {
              @Override
              public void postDeserialize(GithubApiAccessSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, GithubApiAccessSpec src, Gson gson) {
                  Map<Class<? extends GithubApiAccessSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(GithubAppSpec.class, "GithubAppSpec");
                      discriminatorValueByClass.put(GithubTokenSpec.class, "GithubTokenSpec");
                      discriminatorValueByClass.put(GithubApiAccessSpec.class, "GithubApiAccessSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(GithubCredentials.class, new TypeSelector<GithubCredentials>() {
            @Override
            public Class<? extends GithubCredentials> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends GithubCredentials>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("GithubHttpCredentials".toUpperCase(), GithubHttpCredentials.class);
                    classByDiscriminatorValue.put("GithubSshCredentials".toUpperCase(), GithubSshCredentials.class);
                    classByDiscriminatorValue.put("GithubCredentials".toUpperCase(), GithubCredentials.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(GithubCredentials.class, new PostProcessor<GithubCredentials>() {
              @Override
              public void postDeserialize(GithubCredentials result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, GithubCredentials src, Gson gson) {
                  Map<Class<? extends GithubCredentials>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(GithubHttpCredentials.class, "GithubHttpCredentials");
                      discriminatorValueByClass.put(GithubSshCredentials.class, "GithubSshCredentials");
                      discriminatorValueByClass.put(GithubCredentials.class, "GithubCredentials");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(GithubHttpCredentialsSpec.class, new TypeSelector<GithubHttpCredentialsSpec>() {
            @Override
            public Class<? extends GithubHttpCredentialsSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends GithubHttpCredentialsSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("GithubUsernamePassword".toUpperCase(), GithubUsernamePassword.class);
                    classByDiscriminatorValue.put("GithubUsernameToken".toUpperCase(), GithubUsernameToken.class);
                    classByDiscriminatorValue.put("GithubHttpCredentialsSpec".toUpperCase(), GithubHttpCredentialsSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(GithubHttpCredentialsSpec.class, new PostProcessor<GithubHttpCredentialsSpec>() {
              @Override
              public void postDeserialize(GithubHttpCredentialsSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, GithubHttpCredentialsSpec src, Gson gson) {
                  Map<Class<? extends GithubHttpCredentialsSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(GithubUsernamePassword.class, "GithubUsernamePassword");
                      discriminatorValueByClass.put(GithubUsernameToken.class, "GithubUsernameToken");
                      discriminatorValueByClass.put(GithubHttpCredentialsSpec.class, "GithubHttpCredentialsSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(GitlabCredentials.class, new TypeSelector<GitlabCredentials>() {
            @Override
            public Class<? extends GitlabCredentials> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends GitlabCredentials>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("GitlabHttpCredentials".toUpperCase(), GitlabHttpCredentials.class);
                    classByDiscriminatorValue.put("GitlabSshCredentials".toUpperCase(), GitlabSshCredentials.class);
                    classByDiscriminatorValue.put("GitlabCredentials".toUpperCase(), GitlabCredentials.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(GitlabCredentials.class, new PostProcessor<GitlabCredentials>() {
              @Override
              public void postDeserialize(GitlabCredentials result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, GitlabCredentials src, Gson gson) {
                  Map<Class<? extends GitlabCredentials>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(GitlabHttpCredentials.class, "GitlabHttpCredentials");
                      discriminatorValueByClass.put(GitlabSshCredentials.class, "GitlabSshCredentials");
                      discriminatorValueByClass.put(GitlabCredentials.class, "GitlabCredentials");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(GitlabHttpCredentialsSpec.class, new TypeSelector<GitlabHttpCredentialsSpec>() {
            @Override
            public Class<? extends GitlabHttpCredentialsSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends GitlabHttpCredentialsSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("GitlabKerberos".toUpperCase(), GitlabKerberos.class);
                    classByDiscriminatorValue.put("GitlabUsernamePassword".toUpperCase(), GitlabUsernamePassword.class);
                    classByDiscriminatorValue.put("GitlabUsernameToken".toUpperCase(), GitlabUsernameToken.class);
                    classByDiscriminatorValue.put("GitlabHttpCredentialsSpec".toUpperCase(), GitlabHttpCredentialsSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(GitlabHttpCredentialsSpec.class, new PostProcessor<GitlabHttpCredentialsSpec>() {
              @Override
              public void postDeserialize(GitlabHttpCredentialsSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, GitlabHttpCredentialsSpec src, Gson gson) {
                  Map<Class<? extends GitlabHttpCredentialsSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(GitlabKerberos.class, "GitlabKerberos");
                      discriminatorValueByClass.put(GitlabUsernamePassword.class, "GitlabUsernamePassword");
                      discriminatorValueByClass.put(GitlabUsernameToken.class, "GitlabUsernameToken");
                      discriminatorValueByClass.put(GitlabHttpCredentialsSpec.class, "GitlabHttpCredentialsSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(GitlabApiAccessSpec.class, new TypeSelector<GitlabApiAccessSpec>() {
            @Override
            public Class<? extends GitlabApiAccessSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends GitlabApiAccessSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("GitlabTokenSpec".toUpperCase(), GitlabTokenSpec.class);
                    classByDiscriminatorValue.put("GitlabApiAccessSpec".toUpperCase(), GitlabApiAccessSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(GitlabApiAccessSpec.class, new PostProcessor<GitlabApiAccessSpec>() {
              @Override
              public void postDeserialize(GitlabApiAccessSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, GitlabApiAccessSpec src, Gson gson) {
                  Map<Class<? extends GitlabApiAccessSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(GitlabTokenSpec.class, "GitlabTokenSpec");
                      discriminatorValueByClass.put(GitlabApiAccessSpec.class, "GitlabApiAccessSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(HttpHelmAuthCredentials.class, new TypeSelector<HttpHelmAuthCredentials>() {
            @Override
            public Class<? extends HttpHelmAuthCredentials> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends HttpHelmAuthCredentials>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("HttpHelmUsernamePassword".toUpperCase(), HttpHelmUsernamePassword.class);
                    classByDiscriminatorValue.put("HttpHelmAuthCredentials".toUpperCase(), HttpHelmAuthCredentials.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(HttpHelmAuthCredentials.class, new PostProcessor<HttpHelmAuthCredentials>() {
              @Override
              public void postDeserialize(HttpHelmAuthCredentials result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, HttpHelmAuthCredentials src, Gson gson) {
                  Map<Class<? extends HttpHelmAuthCredentials>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(HttpHelmUsernamePassword.class, "HttpHelmUsernamePassword");
                      discriminatorValueByClass.put(HttpHelmAuthCredentials.class, "HttpHelmAuthCredentials");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(Source.class, new TypeSelector<Source>() {
            @Override
            public Class<? extends Source> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends Source>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("InvitationSource".toUpperCase(), InvitationSource.class);
                    classByDiscriminatorValue.put("Source".toUpperCase(), Source.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(Source.class, new PostProcessor<Source>() {
              @Override
              public void postDeserialize(Source result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, Source src, Gson gson) {
                  Map<Class<? extends Source>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(InvitationSource.class, "InvitationSource");
                      discriminatorValueByClass.put(Source.class, "Source");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(BaseSSHSpec.class, new TypeSelector<BaseSSHSpec>() {
            @Override
            public Class<? extends BaseSSHSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends BaseSSHSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("KerberosConfig".toUpperCase(), KerberosConfig.class);
                    classByDiscriminatorValue.put("SSHConfig".toUpperCase(), SSHConfig.class);
                    classByDiscriminatorValue.put("BaseSSHSpec".toUpperCase(), BaseSSHSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(BaseSSHSpec.class, new PostProcessor<BaseSSHSpec>() {
              @Override
              public void postDeserialize(BaseSSHSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, BaseSSHSpec src, Gson gson) {
                  Map<Class<? extends BaseSSHSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(KerberosConfig.class, "KerberosConfig");
                      discriminatorValueByClass.put(SSHConfig.class, "SSHConfig");
                      discriminatorValueByClass.put(BaseSSHSpec.class, "BaseSSHSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(KubernetesAuthCredential.class, new TypeSelector<KubernetesAuthCredential>() {
            @Override
            public Class<? extends KubernetesAuthCredential> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends KubernetesAuthCredential>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("KubernetesClientKeyCert".toUpperCase(), KubernetesClientKeyCert.class);
                    classByDiscriminatorValue.put("KubernetesOpenIdConnect".toUpperCase(), KubernetesOpenIdConnect.class);
                    classByDiscriminatorValue.put("KubernetesServiceAccount".toUpperCase(), KubernetesServiceAccount.class);
                    classByDiscriminatorValue.put("KubernetesUserNamePassword".toUpperCase(), KubernetesUserNamePassword.class);
                    classByDiscriminatorValue.put("KubernetesAuthCredential".toUpperCase(), KubernetesAuthCredential.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(KubernetesAuthCredential.class, new PostProcessor<KubernetesAuthCredential>() {
              @Override
              public void postDeserialize(KubernetesAuthCredential result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, KubernetesAuthCredential src, Gson gson) {
                  Map<Class<? extends KubernetesAuthCredential>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(KubernetesClientKeyCert.class, "KubernetesClientKeyCert");
                      discriminatorValueByClass.put(KubernetesOpenIdConnect.class, "KubernetesOpenIdConnect");
                      discriminatorValueByClass.put(KubernetesServiceAccount.class, "KubernetesServiceAccount");
                      discriminatorValueByClass.put(KubernetesUserNamePassword.class, "KubernetesUserNamePassword");
                      discriminatorValueByClass.put(KubernetesAuthCredential.class, "KubernetesAuthCredential");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(KubernetesCredentialSpec.class, new TypeSelector<KubernetesCredentialSpec>() {
            @Override
            public Class<? extends KubernetesCredentialSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends KubernetesCredentialSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("KubernetesClusterDetails".toUpperCase(), KubernetesClusterDetails.class);
                    classByDiscriminatorValue.put("KubernetesCredentialSpec".toUpperCase(), KubernetesCredentialSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(KubernetesCredentialSpec.class, new PostProcessor<KubernetesCredentialSpec>() {
              @Override
              public void postDeserialize(KubernetesCredentialSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, KubernetesCredentialSpec src, Gson gson) {
                  Map<Class<? extends KubernetesCredentialSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(KubernetesClusterDetails.class, "KubernetesClusterDetails");
                      discriminatorValueByClass.put(KubernetesCredentialSpec.class, "KubernetesCredentialSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(NexusAuthCredentials.class, new TypeSelector<NexusAuthCredentials>() {
            @Override
            public Class<? extends NexusAuthCredentials> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends NexusAuthCredentials>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("NexusUsernamePasswordAuth".toUpperCase(), NexusUsernamePasswordAuth.class);
                    classByDiscriminatorValue.put("NexusAuthCredentials".toUpperCase(), NexusAuthCredentials.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, ""));
            }
          })
          .registerPostProcessor(NexusAuthCredentials.class, new PostProcessor<NexusAuthCredentials>() {
              @Override
              public void postDeserialize(NexusAuthCredentials result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, NexusAuthCredentials src, Gson gson) {
                  Map<Class<? extends NexusAuthCredentials>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(NexusUsernamePasswordAuth.class, "NexusUsernamePasswordAuth");
                      discriminatorValueByClass.put(NexusAuthCredentials.class, "NexusAuthCredentials");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has(""))
                      {
                          ((JsonObject) result).addProperty("", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(PmsNotificationChannel.class, new TypeSelector<PmsNotificationChannel>() {
            @Override
            public Class<? extends PmsNotificationChannel> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends PmsNotificationChannel>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("PmsEmailChannel".toUpperCase(), PmsEmailChannel.class);
                    classByDiscriminatorValue.put("PmsMSTeamChannel".toUpperCase(), PmsMSTeamChannel.class);
                    classByDiscriminatorValue.put("PmsPagerDutyChannel".toUpperCase(), PmsPagerDutyChannel.class);
                    classByDiscriminatorValue.put("PmsSlackChannel".toUpperCase(), PmsSlackChannel.class);
                    classByDiscriminatorValue.put("PmsNotificationChannel".toUpperCase(), PmsNotificationChannel.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(PmsNotificationChannel.class, new PostProcessor<PmsNotificationChannel>() {
              @Override
              public void postDeserialize(PmsNotificationChannel result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, PmsNotificationChannel src, Gson gson) {
                  Map<Class<? extends PmsNotificationChannel>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(PmsEmailChannel.class, "PmsEmailChannel");
                      discriminatorValueByClass.put(PmsMSTeamChannel.class, "PmsMSTeamChannel");
                      discriminatorValueByClass.put(PmsPagerDutyChannel.class, "PmsPagerDutyChannel");
                      discriminatorValueByClass.put(PmsSlackChannel.class, "PmsSlackChannel");
                      discriminatorValueByClass.put(PmsNotificationChannel.class, "PmsNotificationChannel");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(SSHCredentialSpec.class, new TypeSelector<SSHCredentialSpec>() {
            @Override
            public Class<? extends SSHCredentialSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends SSHCredentialSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("SSHKeyPathCredential".toUpperCase(), SSHKeyPathCredential.class);
                    classByDiscriminatorValue.put("SSHKeyReferenceCredentialDTO".toUpperCase(), SSHKeyReferenceCredentialDTO.class);
                    classByDiscriminatorValue.put("SSHPasswordCredentialDTO".toUpperCase(), SSHPasswordCredentialDTO.class);
                    classByDiscriminatorValue.put("SSHCredentialSpec".toUpperCase(), SSHCredentialSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "credentialType"));
            }
          })
          .registerPostProcessor(SSHCredentialSpec.class, new PostProcessor<SSHCredentialSpec>() {
              @Override
              public void postDeserialize(SSHCredentialSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, SSHCredentialSpec src, Gson gson) {
                  Map<Class<? extends SSHCredentialSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(SSHKeyPathCredential.class, "SSHKeyPathCredential");
                      discriminatorValueByClass.put(SSHKeyReferenceCredentialDTO.class, "SSHKeyReferenceCredentialDTO");
                      discriminatorValueByClass.put(SSHPasswordCredentialDTO.class, "SSHPasswordCredentialDTO");
                      discriminatorValueByClass.put(SSHCredentialSpec.class, "SSHCredentialSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("credentialType"))
                      {
                          ((JsonObject) result).addProperty("credentialType", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(SecretSpec.class, new TypeSelector<SecretSpec>() {
            @Override
            public Class<? extends SecretSpec> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends SecretSpec>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("SSHKeySpec".toUpperCase(), SSHKeySpec.class);
                    classByDiscriminatorValue.put("SecretFileSpe".toUpperCase(), SecretFileSpe.class);
                    classByDiscriminatorValue.put("SecretTextSpec".toUpperCase(), SecretTextSpec.class);
                    classByDiscriminatorValue.put("SecretSpec".toUpperCase(), SecretSpec.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(SecretSpec.class, new PostProcessor<SecretSpec>() {
              @Override
              public void postDeserialize(SecretSpec result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, SecretSpec src, Gson gson) {
                  Map<Class<? extends SecretSpec>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(SSHKeySpec.class, "SSHKeySpec");
                      discriminatorValueByClass.put(SecretFileSpe.class, "SecretFileSpe");
                      discriminatorValueByClass.put(SecretTextSpec.class, "SecretTextSpec");
                      discriminatorValueByClass.put(SecretSpec.class, "SecretSpec");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(ErrorMetadata.class, new TypeSelector<ErrorMetadata>() {
            @Override
            public Class<? extends ErrorMetadata> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends ErrorMetadata>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("SampleErrorMetadata".toUpperCase(), SampleErrorMetadata.class);
                    classByDiscriminatorValue.put("TemplateInputsErrorMetadataDTO".toUpperCase(), TemplateInputsErrorMetadataDTO.class);
                    classByDiscriminatorValue.put("ErrorMetadata".toUpperCase(), ErrorMetadata.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(ErrorMetadata.class, new PostProcessor<ErrorMetadata>() {
              @Override
              public void postDeserialize(ErrorMetadata result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, ErrorMetadata src, Gson gson) {
                  Map<Class<? extends ErrorMetadata>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(SampleErrorMetadata.class, "SampleErrorMetadata");
                      discriminatorValueByClass.put(TemplateInputsErrorMetadataDTO.class, "TemplateInputsErrorMetadataDTO");
                      discriminatorValueByClass.put(ErrorMetadata.class, "ErrorMetadata");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(TGTGenerationSpecDTO.class, new TypeSelector<TGTGenerationSpecDTO>() {
            @Override
            public Class<? extends TGTGenerationSpecDTO> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends TGTGenerationSpecDTO>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("TGTKeyTabFilePathSpecDTO".toUpperCase(), TGTKeyTabFilePathSpecDTO.class);
                    classByDiscriminatorValue.put("TGTPasswordSpecDTO".toUpperCase(), TGTPasswordSpecDTO.class);
                    classByDiscriminatorValue.put("TGTGenerationSpecDTO".toUpperCase(), TGTGenerationSpecDTO.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "tgtGenerationMethod"));
            }
          })
          .registerPostProcessor(TGTGenerationSpecDTO.class, new PostProcessor<TGTGenerationSpecDTO>() {
              @Override
              public void postDeserialize(TGTGenerationSpecDTO result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, TGTGenerationSpecDTO src, Gson gson) {
                  Map<Class<? extends TGTGenerationSpecDTO>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(TGTKeyTabFilePathSpecDTO.class, "TGTKeyTabFilePathSpecDTO");
                      discriminatorValueByClass.put(TGTPasswordSpecDTO.class, "TGTPasswordSpecDTO");
                      discriminatorValueByClass.put(TGTGenerationSpecDTO.class, "TGTGenerationSpecDTO");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("tgtGenerationMethod"))
                      {
                          ((JsonObject) result).addProperty("tgtGenerationMethod", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
          .registerTypeSelector(ViewCondition.class, new TypeSelector<ViewCondition>() {
            @Override
            public Class<? extends ViewCondition> getClassForElement(JsonElement readElement) {
                Map<String, Class<? extends ViewCondition>> classByDiscriminatorValue = new HashMap<>();
                    classByDiscriminatorValue.put("ViewIdCondition".toUpperCase(), ViewIdCondition.class);
                    classByDiscriminatorValue.put("ViewCondition".toUpperCase(), ViewCondition.class);
                return getClassByDiscriminator(
                            classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "type"));
            }
          })
          .registerPostProcessor(ViewCondition.class, new PostProcessor<ViewCondition>() {
              @Override
              public void postDeserialize(ViewCondition result, JsonElement src, Gson gson) {

              }

              @Override
              public void postSerialize(JsonElement result, ViewCondition src, Gson gson) {
                  Map<Class<? extends ViewCondition>, String> discriminatorValueByClass = new HashMap<>();
                      discriminatorValueByClass.put(ViewIdCondition.class, "ViewIdCondition");
                      discriminatorValueByClass.put(ViewCondition.class, "ViewCondition");
                  if(result instanceof JsonObject)
                  {
                      if(!((JsonObject) result).has("type"))
                      {
                          ((JsonObject) result).addProperty("type", discriminatorValueByClass.get(src.getClass()));
                      }
                  }
              }
          })
        ;
        return fireBuilder.createGsonBuilder();
    }

    private static String getDiscriminatorValue(JsonElement readElement, String discriminatorField) {
        JsonElement element = readElement.getAsJsonObject().get(discriminatorField);
        if(null == element) {
            throw new IllegalArgumentException("missing discriminator field: <" + discriminatorField + ">");
        }
        return element.getAsString();
    }

    private static <T> Class<? extends T> getClassByDiscriminator(Map<String, Class<? extends T>> classByDiscriminatorValue, String discriminatorValue) {
        Class<? extends T> clazz = classByDiscriminatorValue.get(discriminatorValue.toUpperCase());
        if(null == clazz) {
            throw new IllegalArgumentException("cannot determine model class of name: <" + discriminatorValue + ">");
        }
        return clazz;
    }

    public JSON() {
        gson = createGson()
            .registerTypeAdapter(Date.class, dateTypeAdapter)
            .registerTypeAdapter(java.sql.Date.class, sqlDateTypeAdapter)
            .registerTypeAdapter(OffsetDateTime.class, offsetDateTimeTypeAdapter)
            .registerTypeAdapter(LocalDate.class, localDateTypeAdapter)
            .create();
    }

    /**
     * Get Gson.
     *
     * @return Gson
     */
    public Gson getGson() {
        return gson;
    }

    /**
     * Set Gson.
     *
     * @param gson Gson
     * @return JSON
     */
    public JSON setGson(Gson gson) {
        this.gson = gson;
        return this;
    }

    public JSON setLenientOnJson(boolean lenientOnJson) {
        isLenientOnJson = lenientOnJson;
        return this;
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    public String serialize(Object obj) {
        return gson.toJson(obj);
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
     */
    @SuppressWarnings("unchecked")
    public <T> T deserialize(String body, Type returnType) {
        try {
            if (isLenientOnJson) {
                JsonReader jsonReader = new JsonReader(new StringReader(body));
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.setLenient(true);
                return gson.fromJson(jsonReader, returnType);
            } else {
                return gson.fromJson(body, returnType);
            }
        } catch (JsonParseException e) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType.equals(String.class))
                return (T) body;
            else throw (e);
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    public static class OffsetDateTimeTypeAdapter extends TypeAdapter<OffsetDateTime> {

        private DateTimeFormatter formatter;

        public OffsetDateTimeTypeAdapter() {
            this(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        }

        public OffsetDateTimeTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, OffsetDateTime date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public OffsetDateTime read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length()-5) + "Z";
                    }
                    return OffsetDateTime.parse(date, formatter);
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    public class LocalDateTypeAdapter extends TypeAdapter<LocalDate> {

        private DateTimeFormatter formatter;

        public LocalDateTypeAdapter() {
            this(DateTimeFormatter.ISO_LOCAL_DATE);
        }

        public LocalDateTypeAdapter(DateTimeFormatter formatter) {
            this.formatter = formatter;
        }

        public void setFormat(DateTimeFormatter dateFormat) {
            this.formatter = dateFormat;
        }

        @Override
        public void write(JsonWriter out, LocalDate date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                out.value(formatter.format(date));
            }
        }

        @Override
        public LocalDate read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    return LocalDate.parse(date, formatter);
            }
        }
    }

    public JSON setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat);
        return this;
    }

    public JSON setLocalDateFormat(DateTimeFormatter dateFormat) {
        localDateTypeAdapter.setFormat(dateFormat);
        return this;
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    public static class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {

        private DateFormat dateFormat;

        public SqlDateTypeAdapter() {
        }

        public SqlDateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, java.sql.Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = date.toString();
                }
                out.value(value);
            }
        }

        @Override
        public java.sql.Date read(JsonReader in) throws IOException {
            switch (in.peek()) {
                case NULL:
                    in.nextNull();
                    return null;
                default:
                    String date = in.nextString();
                    try {
                        if (dateFormat != null) {
                            return new java.sql.Date(dateFormat.parse(date).getTime());
                        }
                        return new java.sql.Date(ISO8601Utils.parse(date, new ParsePosition(0)).getTime());
                    } catch (ParseException e) {
                        throw new JsonParseException(e);
                    }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, ISO8601Utils will be used.
     */
    public static class DateTypeAdapter extends TypeAdapter<Date> {

        private DateFormat dateFormat;

        public DateTypeAdapter() {
        }

        public DateTypeAdapter(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        public void setFormat(DateFormat dateFormat) {
            this.dateFormat = dateFormat;
        }

        @Override
        public void write(JsonWriter out, Date date) throws IOException {
            if (date == null) {
                out.nullValue();
            } else {
                String value;
                if (dateFormat != null) {
                    value = dateFormat.format(date);
                } else {
                    value = ISO8601Utils.format(date, true);
                }
                out.value(value);
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            try {
                switch (in.peek()) {
                    case NULL:
                        in.nextNull();
                        return null;
                    default:
                        String date = in.nextString();
                        try {
                            if (dateFormat != null) {
                                return dateFormat.parse(date);
                            }
                            return ISO8601Utils.parse(date, new ParsePosition(0));
                        } catch (ParseException e) {
                            throw new JsonParseException(e);
                        }
                }
            } catch (IllegalArgumentException e) {
                throw new JsonParseException(e);
            }
        }
    }

    public JSON setDateFormat(DateFormat dateFormat) {
        dateTypeAdapter.setFormat(dateFormat);
        return this;
    }

    public JSON setSqlDateFormat(DateFormat dateFormat) {
        sqlDateTypeAdapter.setFormat(dateFormat);
        return this;
    }

}
