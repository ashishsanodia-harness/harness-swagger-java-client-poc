/*
 * CD NextGen API Reference
 * This is the Open Api Spec 3 for the NextGen Manager. This is under active development. Beware of the breaking change with respect to the generated code stub  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * OpenAPI spec version: 3.0
 * Contact: contact@harness.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.Descriptor;
import io.swagger.client.model.EnumDescriptor;
import io.swagger.client.model.FieldDescriptorProto;
import io.swagger.client.model.FieldOptions;
import io.swagger.client.model.FileDescriptor;
import io.swagger.client.model.OneofDescriptor;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * FieldDescriptor
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2022-02-16T23:54:49.094+05:30[Asia/Kolkata]")
public class FieldDescriptor {
  @SerializedName("index")
  private Integer index = null;

  @SerializedName("proto")
  private FieldDescriptorProto proto = null;

  @SerializedName("fullName")
  private String fullName = null;

  @SerializedName("jsonName")
  private String jsonName = null;

  @SerializedName("file")
  private FileDescriptor file = null;

  @SerializedName("extensionScope")
  private Descriptor extensionScope = null;

  /**
   * Gets or Sets type
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    DOUBLE("DOUBLE"),
    FLOAT("FLOAT"),
    INT64("INT64"),
    UINT64("UINT64"),
    INT32("INT32"),
    FIXED64("FIXED64"),
    FIXED32("FIXED32"),
    BOOL("BOOL"),
    STRING("STRING"),
    GROUP("GROUP"),
    MESSAGE("MESSAGE"),
    BYTES("BYTES"),
    UINT32("UINT32"),
    ENUM("ENUM"),
    SFIXED32("SFIXED32"),
    SFIXED64("SFIXED64"),
    SINT32("SINT32"),
    SINT64("SINT64");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String input) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return TypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = null;

  @SerializedName("containingType")
  private Descriptor containingType = null;

  @SerializedName("messageType")
  private Descriptor messageType = null;

  @SerializedName("containingOneof")
  private OneofDescriptor containingOneof = null;

  @SerializedName("enumType")
  private EnumDescriptor enumType = null;

  @SerializedName("defaultValue")
  private Object defaultValue = null;

  @SerializedName("options")
  private FieldOptions options = null;

  @SerializedName("optional")
  private Boolean optional = null;

  /**
   * Gets or Sets javaType
   */
  @JsonAdapter(JavaTypeEnum.Adapter.class)
  public enum JavaTypeEnum {
    INT("INT"),
    LONG("LONG"),
    FLOAT("FLOAT"),
    DOUBLE("DOUBLE"),
    BOOLEAN("BOOLEAN"),
    STRING("STRING"),
    BYTE_STRING("BYTE_STRING"),
    ENUM("ENUM"),
    MESSAGE("MESSAGE");

    private String value;

    JavaTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static JavaTypeEnum fromValue(String input) {
      for (JavaTypeEnum b : JavaTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<JavaTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final JavaTypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public JavaTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return JavaTypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("javaType")
  private JavaTypeEnum javaType = null;

  /**
   * Gets or Sets liteJavaType
   */
  @JsonAdapter(LiteJavaTypeEnum.Adapter.class)
  public enum LiteJavaTypeEnum {
    INT("INT"),
    LONG("LONG"),
    FLOAT("FLOAT"),
    DOUBLE("DOUBLE"),
    BOOLEAN("BOOLEAN"),
    STRING("STRING"),
    BYTE_STRING("BYTE_STRING"),
    ENUM("ENUM"),
    MESSAGE("MESSAGE");

    private String value;

    LiteJavaTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static LiteJavaTypeEnum fromValue(String input) {
      for (LiteJavaTypeEnum b : LiteJavaTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<LiteJavaTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LiteJavaTypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public LiteJavaTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return LiteJavaTypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("liteJavaType")
  private LiteJavaTypeEnum liteJavaType = null;

  @SerializedName("packable")
  private Boolean packable = null;

  @SerializedName("required")
  private Boolean required = null;

  @SerializedName("packed")
  private Boolean packed = null;

  @SerializedName("extension")
  private Boolean extension = null;

  @SerializedName("repeated")
  private Boolean repeated = null;

  @SerializedName("mapField")
  private Boolean mapField = null;

  /**
   * Gets or Sets liteType
   */
  @JsonAdapter(LiteTypeEnum.Adapter.class)
  public enum LiteTypeEnum {
    DOUBLE("DOUBLE"),
    FLOAT("FLOAT"),
    INT64("INT64"),
    UINT64("UINT64"),
    INT32("INT32"),
    FIXED64("FIXED64"),
    FIXED32("FIXED32"),
    BOOL("BOOL"),
    STRING("STRING"),
    GROUP("GROUP"),
    MESSAGE("MESSAGE"),
    BYTES("BYTES"),
    UINT32("UINT32"),
    ENUM("ENUM"),
    SFIXED32("SFIXED32"),
    SFIXED64("SFIXED64"),
    SINT32("SINT32"),
    SINT64("SINT64");

    private String value;

    LiteTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static LiteTypeEnum fromValue(String input) {
      for (LiteTypeEnum b : LiteTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<LiteTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LiteTypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public LiteTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return LiteTypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("liteType")
  private LiteTypeEnum liteType = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("number")
  private Integer number = null;

  public FieldDescriptor index(Integer index) {
    this.index = index;
    return this;
  }

   /**
   * Get index
   * @return index
  **/
  @Schema(description = "")
  public Integer getIndex() {
    return index;
  }

  public void setIndex(Integer index) {
    this.index = index;
  }

  public FieldDescriptor proto(FieldDescriptorProto proto) {
    this.proto = proto;
    return this;
  }

   /**
   * Get proto
   * @return proto
  **/
  @Schema(description = "")
  public FieldDescriptorProto getProto() {
    return proto;
  }

  public void setProto(FieldDescriptorProto proto) {
    this.proto = proto;
  }

  public FieldDescriptor fullName(String fullName) {
    this.fullName = fullName;
    return this;
  }

   /**
   * Get fullName
   * @return fullName
  **/
  @Schema(description = "")
  public String getFullName() {
    return fullName;
  }

  public void setFullName(String fullName) {
    this.fullName = fullName;
  }

  public FieldDescriptor jsonName(String jsonName) {
    this.jsonName = jsonName;
    return this;
  }

   /**
   * Get jsonName
   * @return jsonName
  **/
  @Schema(description = "")
  public String getJsonName() {
    return jsonName;
  }

  public void setJsonName(String jsonName) {
    this.jsonName = jsonName;
  }

  public FieldDescriptor file(FileDescriptor file) {
    this.file = file;
    return this;
  }

   /**
   * Get file
   * @return file
  **/
  @Schema(description = "")
  public FileDescriptor getFile() {
    return file;
  }

  public void setFile(FileDescriptor file) {
    this.file = file;
  }

  public FieldDescriptor extensionScope(Descriptor extensionScope) {
    this.extensionScope = extensionScope;
    return this;
  }

   /**
   * Get extensionScope
   * @return extensionScope
  **/
  @Schema(description = "")
  public Descriptor getExtensionScope() {
    return extensionScope;
  }

  public void setExtensionScope(Descriptor extensionScope) {
    this.extensionScope = extensionScope;
  }

  public FieldDescriptor type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Get type
   * @return type
  **/
  @Schema(description = "")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public FieldDescriptor containingType(Descriptor containingType) {
    this.containingType = containingType;
    return this;
  }

   /**
   * Get containingType
   * @return containingType
  **/
  @Schema(description = "")
  public Descriptor getContainingType() {
    return containingType;
  }

  public void setContainingType(Descriptor containingType) {
    this.containingType = containingType;
  }

  public FieldDescriptor messageType(Descriptor messageType) {
    this.messageType = messageType;
    return this;
  }

   /**
   * Get messageType
   * @return messageType
  **/
  @Schema(description = "")
  public Descriptor getMessageType() {
    return messageType;
  }

  public void setMessageType(Descriptor messageType) {
    this.messageType = messageType;
  }

  public FieldDescriptor containingOneof(OneofDescriptor containingOneof) {
    this.containingOneof = containingOneof;
    return this;
  }

   /**
   * Get containingOneof
   * @return containingOneof
  **/
  @Schema(description = "")
  public OneofDescriptor getContainingOneof() {
    return containingOneof;
  }

  public void setContainingOneof(OneofDescriptor containingOneof) {
    this.containingOneof = containingOneof;
  }

  public FieldDescriptor enumType(EnumDescriptor enumType) {
    this.enumType = enumType;
    return this;
  }

   /**
   * Get enumType
   * @return enumType
  **/
  @Schema(description = "")
  public EnumDescriptor getEnumType() {
    return enumType;
  }

  public void setEnumType(EnumDescriptor enumType) {
    this.enumType = enumType;
  }

  public FieldDescriptor defaultValue(Object defaultValue) {
    this.defaultValue = defaultValue;
    return this;
  }

   /**
   * Get defaultValue
   * @return defaultValue
  **/
  @Schema(description = "")
  public Object getDefaultValue() {
    return defaultValue;
  }

  public void setDefaultValue(Object defaultValue) {
    this.defaultValue = defaultValue;
  }

  public FieldDescriptor options(FieldOptions options) {
    this.options = options;
    return this;
  }

   /**
   * Get options
   * @return options
  **/
  @Schema(description = "")
  public FieldOptions getOptions() {
    return options;
  }

  public void setOptions(FieldOptions options) {
    this.options = options;
  }

  public FieldDescriptor optional(Boolean optional) {
    this.optional = optional;
    return this;
  }

   /**
   * Get optional
   * @return optional
  **/
  @Schema(description = "")
  public Boolean isOptional() {
    return optional;
  }

  public void setOptional(Boolean optional) {
    this.optional = optional;
  }

  public FieldDescriptor javaType(JavaTypeEnum javaType) {
    this.javaType = javaType;
    return this;
  }

   /**
   * Get javaType
   * @return javaType
  **/
  @Schema(description = "")
  public JavaTypeEnum getJavaType() {
    return javaType;
  }

  public void setJavaType(JavaTypeEnum javaType) {
    this.javaType = javaType;
  }

  public FieldDescriptor liteJavaType(LiteJavaTypeEnum liteJavaType) {
    this.liteJavaType = liteJavaType;
    return this;
  }

   /**
   * Get liteJavaType
   * @return liteJavaType
  **/
  @Schema(description = "")
  public LiteJavaTypeEnum getLiteJavaType() {
    return liteJavaType;
  }

  public void setLiteJavaType(LiteJavaTypeEnum liteJavaType) {
    this.liteJavaType = liteJavaType;
  }

  public FieldDescriptor packable(Boolean packable) {
    this.packable = packable;
    return this;
  }

   /**
   * Get packable
   * @return packable
  **/
  @Schema(description = "")
  public Boolean isPackable() {
    return packable;
  }

  public void setPackable(Boolean packable) {
    this.packable = packable;
  }

  public FieldDescriptor required(Boolean required) {
    this.required = required;
    return this;
  }

   /**
   * Get required
   * @return required
  **/
  @Schema(description = "")
  public Boolean isRequired() {
    return required;
  }

  public void setRequired(Boolean required) {
    this.required = required;
  }

  public FieldDescriptor packed(Boolean packed) {
    this.packed = packed;
    return this;
  }

   /**
   * Get packed
   * @return packed
  **/
  @Schema(description = "")
  public Boolean isPacked() {
    return packed;
  }

  public void setPacked(Boolean packed) {
    this.packed = packed;
  }

  public FieldDescriptor extension(Boolean extension) {
    this.extension = extension;
    return this;
  }

   /**
   * Get extension
   * @return extension
  **/
  @Schema(description = "")
  public Boolean isExtension() {
    return extension;
  }

  public void setExtension(Boolean extension) {
    this.extension = extension;
  }

  public FieldDescriptor repeated(Boolean repeated) {
    this.repeated = repeated;
    return this;
  }

   /**
   * Get repeated
   * @return repeated
  **/
  @Schema(description = "")
  public Boolean isRepeated() {
    return repeated;
  }

  public void setRepeated(Boolean repeated) {
    this.repeated = repeated;
  }

  public FieldDescriptor mapField(Boolean mapField) {
    this.mapField = mapField;
    return this;
  }

   /**
   * Get mapField
   * @return mapField
  **/
  @Schema(description = "")
  public Boolean isMapField() {
    return mapField;
  }

  public void setMapField(Boolean mapField) {
    this.mapField = mapField;
  }

  public FieldDescriptor liteType(LiteTypeEnum liteType) {
    this.liteType = liteType;
    return this;
  }

   /**
   * Get liteType
   * @return liteType
  **/
  @Schema(description = "")
  public LiteTypeEnum getLiteType() {
    return liteType;
  }

  public void setLiteType(LiteTypeEnum liteType) {
    this.liteType = liteType;
  }

  public FieldDescriptor name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Get name
   * @return name
  **/
  @Schema(description = "")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public FieldDescriptor number(Integer number) {
    this.number = number;
    return this;
  }

   /**
   * Get number
   * @return number
  **/
  @Schema(description = "")
  public Integer getNumber() {
    return number;
  }

  public void setNumber(Integer number) {
    this.number = number;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FieldDescriptor fieldDescriptor = (FieldDescriptor) o;
    return Objects.equals(this.index, fieldDescriptor.index) &&
        Objects.equals(this.proto, fieldDescriptor.proto) &&
        Objects.equals(this.fullName, fieldDescriptor.fullName) &&
        Objects.equals(this.jsonName, fieldDescriptor.jsonName) &&
        Objects.equals(this.file, fieldDescriptor.file) &&
        Objects.equals(this.extensionScope, fieldDescriptor.extensionScope) &&
        Objects.equals(this.type, fieldDescriptor.type) &&
        Objects.equals(this.containingType, fieldDescriptor.containingType) &&
        Objects.equals(this.messageType, fieldDescriptor.messageType) &&
        Objects.equals(this.containingOneof, fieldDescriptor.containingOneof) &&
        Objects.equals(this.enumType, fieldDescriptor.enumType) &&
        Objects.equals(this.defaultValue, fieldDescriptor.defaultValue) &&
        Objects.equals(this.options, fieldDescriptor.options) &&
        Objects.equals(this.optional, fieldDescriptor.optional) &&
        Objects.equals(this.javaType, fieldDescriptor.javaType) &&
        Objects.equals(this.liteJavaType, fieldDescriptor.liteJavaType) &&
        Objects.equals(this.packable, fieldDescriptor.packable) &&
        Objects.equals(this.required, fieldDescriptor.required) &&
        Objects.equals(this.packed, fieldDescriptor.packed) &&
        Objects.equals(this.extension, fieldDescriptor.extension) &&
        Objects.equals(this.repeated, fieldDescriptor.repeated) &&
        Objects.equals(this.mapField, fieldDescriptor.mapField) &&
        Objects.equals(this.liteType, fieldDescriptor.liteType) &&
        Objects.equals(this.name, fieldDescriptor.name) &&
        Objects.equals(this.number, fieldDescriptor.number);
  }

  @Override
  public int hashCode() {
    return Objects.hash(index, proto, fullName, jsonName, file, extensionScope, type, containingType, messageType, containingOneof, enumType, defaultValue, options, optional, javaType, liteJavaType, packable, required, packed, extension, repeated, mapField, liteType, name, number);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FieldDescriptor {\n");
    
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    proto: ").append(toIndentedString(proto)).append("\n");
    sb.append("    fullName: ").append(toIndentedString(fullName)).append("\n");
    sb.append("    jsonName: ").append(toIndentedString(jsonName)).append("\n");
    sb.append("    file: ").append(toIndentedString(file)).append("\n");
    sb.append("    extensionScope: ").append(toIndentedString(extensionScope)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    containingType: ").append(toIndentedString(containingType)).append("\n");
    sb.append("    messageType: ").append(toIndentedString(messageType)).append("\n");
    sb.append("    containingOneof: ").append(toIndentedString(containingOneof)).append("\n");
    sb.append("    enumType: ").append(toIndentedString(enumType)).append("\n");
    sb.append("    defaultValue: ").append(toIndentedString(defaultValue)).append("\n");
    sb.append("    options: ").append(toIndentedString(options)).append("\n");
    sb.append("    optional: ").append(toIndentedString(optional)).append("\n");
    sb.append("    javaType: ").append(toIndentedString(javaType)).append("\n");
    sb.append("    liteJavaType: ").append(toIndentedString(liteJavaType)).append("\n");
    sb.append("    packable: ").append(toIndentedString(packable)).append("\n");
    sb.append("    required: ").append(toIndentedString(required)).append("\n");
    sb.append("    packed: ").append(toIndentedString(packed)).append("\n");
    sb.append("    extension: ").append(toIndentedString(extension)).append("\n");
    sb.append("    repeated: ").append(toIndentedString(repeated)).append("\n");
    sb.append("    mapField: ").append(toIndentedString(mapField)).append("\n");
    sb.append("    liteType: ").append(toIndentedString(liteType)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    number: ").append(toIndentedString(number)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
