/*
 * CD NextGen API Reference
 * This is the Open Api Spec 3 for the NextGen Manager. This is under active development. Beware of the breaking change with respect to the generated code stub  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * OpenAPI spec version: 3.0
 * Contact: contact@harness.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ConnectorConfig;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * This contains the Vault Connector configuration.
 */
@Schema(description = "This contains the Vault Connector configuration.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2022-02-16T23:54:49.094+05:30[Asia/Kolkata]")
public class VaultConnector extends ConnectorConfig {
  @SerializedName("authToken")
  private String authToken = null;

  @SerializedName("basePath")
  private String basePath = null;

  @SerializedName("vaultUrl")
  private String vaultUrl = null;

  @SerializedName("isReadOnly")
  private Boolean isReadOnly = null;

  @SerializedName("renewalIntervalMinutes")
  private Long renewalIntervalMinutes = null;

  @SerializedName("secretEngineManuallyConfigured")
  private Boolean secretEngineManuallyConfigured = null;

  @SerializedName("secretEngineName")
  private String secretEngineName = null;

  @SerializedName("appRoleId")
  private String appRoleId = null;

  @SerializedName("secretId")
  private String secretId = null;

  @SerializedName("isDefault")
  private Boolean isDefault = null;

  @SerializedName("secretEngineVersion")
  private Integer secretEngineVersion = null;

  @SerializedName("delegateSelectors")
  private List<String> delegateSelectors = null;

  @SerializedName("namespace")
  private String namespace = null;

  @SerializedName("sinkPath")
  private String sinkPath = null;

  @SerializedName("useVaultAgent")
  private Boolean useVaultAgent = null;

  @SerializedName("default")
  private Boolean _default = null;

  /**
   * Gets or Sets accessType
   */
  @JsonAdapter(AccessTypeEnum.Adapter.class)
  public enum AccessTypeEnum {
    APP_ROLE("APP_ROLE"),
    TOKEN("TOKEN"),
    VAULT_AGENT("VAULT_AGENT");

    private String value;

    AccessTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AccessTypeEnum fromValue(String input) {
      for (AccessTypeEnum b : AccessTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AccessTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AccessTypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public AccessTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return AccessTypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("accessType")
  private AccessTypeEnum accessType = null;

  @SerializedName("readOnly")
  private Boolean readOnly = null;

  public VaultConnector authToken(String authToken) {
    this.authToken = authToken;
    return this;
  }

   /**
   * Get authToken
   * @return authToken
  **/
  @Schema(description = "")
  public String getAuthToken() {
    return authToken;
  }

  public void setAuthToken(String authToken) {
    this.authToken = authToken;
  }

  public VaultConnector basePath(String basePath) {
    this.basePath = basePath;
    return this;
  }

   /**
   * This is the location of the Vault directory where Secret will be stored.
   * @return basePath
  **/
  @Schema(description = "This is the location of the Vault directory where Secret will be stored.")
  public String getBasePath() {
    return basePath;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public VaultConnector vaultUrl(String vaultUrl) {
    this.vaultUrl = vaultUrl;
    return this;
  }

   /**
   * URL of the Vault.
   * @return vaultUrl
  **/
  @Schema(description = "URL of the Vault.")
  public String getVaultUrl() {
    return vaultUrl;
  }

  public void setVaultUrl(String vaultUrl) {
    this.vaultUrl = vaultUrl;
  }

  public VaultConnector isReadOnly(Boolean isReadOnly) {
    this.isReadOnly = isReadOnly;
    return this;
  }

   /**
   * Boolean value to indicate if the Secret Manager created is read only.
   * @return isReadOnly
  **/
  @Schema(description = "Boolean value to indicate if the Secret Manager created is read only.")
  public Boolean isIsReadOnly() {
    return isReadOnly;
  }

  public void setIsReadOnly(Boolean isReadOnly) {
    this.isReadOnly = isReadOnly;
  }

  public VaultConnector renewalIntervalMinutes(Long renewalIntervalMinutes) {
    this.renewalIntervalMinutes = renewalIntervalMinutes;
    return this;
  }

   /**
   * This is the time interval for token renewal.
   * @return renewalIntervalMinutes
  **/
  @Schema(description = "This is the time interval for token renewal.")
  public Long getRenewalIntervalMinutes() {
    return renewalIntervalMinutes;
  }

  public void setRenewalIntervalMinutes(Long renewalIntervalMinutes) {
    this.renewalIntervalMinutes = renewalIntervalMinutes;
  }

  public VaultConnector secretEngineManuallyConfigured(Boolean secretEngineManuallyConfigured) {
    this.secretEngineManuallyConfigured = secretEngineManuallyConfigured;
    return this;
  }

   /**
   * Manually entered Secret Engine.
   * @return secretEngineManuallyConfigured
  **/
  @Schema(description = "Manually entered Secret Engine.")
  public Boolean isSecretEngineManuallyConfigured() {
    return secretEngineManuallyConfigured;
  }

  public void setSecretEngineManuallyConfigured(Boolean secretEngineManuallyConfigured) {
    this.secretEngineManuallyConfigured = secretEngineManuallyConfigured;
  }

  public VaultConnector secretEngineName(String secretEngineName) {
    this.secretEngineName = secretEngineName;
    return this;
  }

   /**
   * Name of the Secret Engine.
   * @return secretEngineName
  **/
  @Schema(description = "Name of the Secret Engine.")
  public String getSecretEngineName() {
    return secretEngineName;
  }

  public void setSecretEngineName(String secretEngineName) {
    this.secretEngineName = secretEngineName;
  }

  public VaultConnector appRoleId(String appRoleId) {
    this.appRoleId = appRoleId;
    return this;
  }

   /**
   * ID of App Role.
   * @return appRoleId
  **/
  @Schema(description = "ID of App Role.")
  public String getAppRoleId() {
    return appRoleId;
  }

  public void setAppRoleId(String appRoleId) {
    this.appRoleId = appRoleId;
  }

  public VaultConnector secretId(String secretId) {
    this.secretId = secretId;
    return this;
  }

   /**
   * Get secretId
   * @return secretId
  **/
  @Schema(description = "")
  public String getSecretId() {
    return secretId;
  }

  public void setSecretId(String secretId) {
    this.secretId = secretId;
  }

  public VaultConnector isDefault(Boolean isDefault) {
    this.isDefault = isDefault;
    return this;
  }

   /**
   * Get isDefault
   * @return isDefault
  **/
  @Schema(description = "")
  public Boolean isIsDefault() {
    return isDefault;
  }

  public void setIsDefault(Boolean isDefault) {
    this.isDefault = isDefault;
  }

  public VaultConnector secretEngineVersion(Integer secretEngineVersion) {
    this.secretEngineVersion = secretEngineVersion;
    return this;
  }

   /**
   * Version of Secret Engine.
   * @return secretEngineVersion
  **/
  @Schema(description = "Version of Secret Engine.")
  public Integer getSecretEngineVersion() {
    return secretEngineVersion;
  }

  public void setSecretEngineVersion(Integer secretEngineVersion) {
    this.secretEngineVersion = secretEngineVersion;
  }

  public VaultConnector delegateSelectors(List<String> delegateSelectors) {
    this.delegateSelectors = delegateSelectors;
    return this;
  }

  public VaultConnector addDelegateSelectorsItem(String delegateSelectorsItem) {
    if (this.delegateSelectors == null) {
      this.delegateSelectors = new ArrayList<String>();
    }
    this.delegateSelectors.add(delegateSelectorsItem);
    return this;
  }

   /**
   * List of Delegate Selectors that belong to the same Delegate and are used to connect to the Secret Manager.
   * @return delegateSelectors
  **/
  @Schema(description = "List of Delegate Selectors that belong to the same Delegate and are used to connect to the Secret Manager.")
  public List<String> getDelegateSelectors() {
    return delegateSelectors;
  }

  public void setDelegateSelectors(List<String> delegateSelectors) {
    this.delegateSelectors = delegateSelectors;
  }

  public VaultConnector namespace(String namespace) {
    this.namespace = namespace;
    return this;
  }

   /**
   * This is the Vault namespace where Secret will be created.
   * @return namespace
  **/
  @Schema(description = "This is the Vault namespace where Secret will be created.")
  public String getNamespace() {
    return namespace;
  }

  public void setNamespace(String namespace) {
    this.namespace = namespace;
  }

  public VaultConnector sinkPath(String sinkPath) {
    this.sinkPath = sinkPath;
    return this;
  }

   /**
   * Get sinkPath
   * @return sinkPath
  **/
  @Schema(description = "")
  public String getSinkPath() {
    return sinkPath;
  }

  public void setSinkPath(String sinkPath) {
    this.sinkPath = sinkPath;
  }

  public VaultConnector useVaultAgent(Boolean useVaultAgent) {
    this.useVaultAgent = useVaultAgent;
    return this;
  }

   /**
   * Boolean value to indicate if Vault Agent is used for authentication.
   * @return useVaultAgent
  **/
  @Schema(description = "Boolean value to indicate if Vault Agent is used for authentication.")
  public Boolean isUseVaultAgent() {
    return useVaultAgent;
  }

  public void setUseVaultAgent(Boolean useVaultAgent) {
    this.useVaultAgent = useVaultAgent;
  }

  public VaultConnector _default(Boolean _default) {
    this._default = _default;
    return this;
  }

   /**
   * Get _default
   * @return _default
  **/
  @Schema(description = "")
  public Boolean isDefault() {
    return _default;
  }

  public void setDefault(Boolean _default) {
    this._default = _default;
  }

  public VaultConnector accessType(AccessTypeEnum accessType) {
    this.accessType = accessType;
    return this;
  }

   /**
   * Get accessType
   * @return accessType
  **/
  @Schema(description = "")
  public AccessTypeEnum getAccessType() {
    return accessType;
  }

  public void setAccessType(AccessTypeEnum accessType) {
    this.accessType = accessType;
  }

  public VaultConnector readOnly(Boolean readOnly) {
    this.readOnly = readOnly;
    return this;
  }

   /**
   * Get readOnly
   * @return readOnly
  **/
  @Schema(description = "")
  public Boolean isReadOnly() {
    return readOnly;
  }

  public void setReadOnly(Boolean readOnly) {
    this.readOnly = readOnly;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VaultConnector vaultConnector = (VaultConnector) o;
    return Objects.equals(this.authToken, vaultConnector.authToken) &&
        Objects.equals(this.basePath, vaultConnector.basePath) &&
        Objects.equals(this.vaultUrl, vaultConnector.vaultUrl) &&
        Objects.equals(this.isReadOnly, vaultConnector.isReadOnly) &&
        Objects.equals(this.renewalIntervalMinutes, vaultConnector.renewalIntervalMinutes) &&
        Objects.equals(this.secretEngineManuallyConfigured, vaultConnector.secretEngineManuallyConfigured) &&
        Objects.equals(this.secretEngineName, vaultConnector.secretEngineName) &&
        Objects.equals(this.appRoleId, vaultConnector.appRoleId) &&
        Objects.equals(this.secretId, vaultConnector.secretId) &&
        Objects.equals(this.isDefault, vaultConnector.isDefault) &&
        Objects.equals(this.secretEngineVersion, vaultConnector.secretEngineVersion) &&
        Objects.equals(this.delegateSelectors, vaultConnector.delegateSelectors) &&
        Objects.equals(this.namespace, vaultConnector.namespace) &&
        Objects.equals(this.sinkPath, vaultConnector.sinkPath) &&
        Objects.equals(this.useVaultAgent, vaultConnector.useVaultAgent) &&
        Objects.equals(this._default, vaultConnector._default) &&
        Objects.equals(this.accessType, vaultConnector.accessType) &&
        Objects.equals(this.readOnly, vaultConnector.readOnly) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(authToken, basePath, vaultUrl, isReadOnly, renewalIntervalMinutes, secretEngineManuallyConfigured, secretEngineName, appRoleId, secretId, isDefault, secretEngineVersion, delegateSelectors, namespace, sinkPath, useVaultAgent, _default, accessType, readOnly, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VaultConnector {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    authToken: ").append(toIndentedString(authToken)).append("\n");
    sb.append("    basePath: ").append(toIndentedString(basePath)).append("\n");
    sb.append("    vaultUrl: ").append(toIndentedString(vaultUrl)).append("\n");
    sb.append("    isReadOnly: ").append(toIndentedString(isReadOnly)).append("\n");
    sb.append("    renewalIntervalMinutes: ").append(toIndentedString(renewalIntervalMinutes)).append("\n");
    sb.append("    secretEngineManuallyConfigured: ").append(toIndentedString(secretEngineManuallyConfigured)).append("\n");
    sb.append("    secretEngineName: ").append(toIndentedString(secretEngineName)).append("\n");
    sb.append("    appRoleId: ").append(toIndentedString(appRoleId)).append("\n");
    sb.append("    secretId: ").append(toIndentedString(secretId)).append("\n");
    sb.append("    isDefault: ").append(toIndentedString(isDefault)).append("\n");
    sb.append("    secretEngineVersion: ").append(toIndentedString(secretEngineVersion)).append("\n");
    sb.append("    delegateSelectors: ").append(toIndentedString(delegateSelectors)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    sinkPath: ").append(toIndentedString(sinkPath)).append("\n");
    sb.append("    useVaultAgent: ").append(toIndentedString(useVaultAgent)).append("\n");
    sb.append("    _default: ").append(toIndentedString(_default)).append("\n");
    sb.append("    accessType: ").append(toIndentedString(accessType)).append("\n");
    sb.append("    readOnly: ").append(toIndentedString(readOnly)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
