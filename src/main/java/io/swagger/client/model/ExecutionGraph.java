/*
 * CD NextGen API Reference
 * This is the Open Api Spec 3 for the NextGen Manager. This is under active development. Beware of the breaking change with respect to the generated code stub  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * OpenAPI spec version: 3.0
 * Contact: contact@harness.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ExecutionNode;
import io.swagger.client.model.ExecutionNodeAdjacencyList;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * ExecutionGraph
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2022-02-16T23:54:49.094+05:30[Asia/Kolkata]")
public class ExecutionGraph {
  @SerializedName("rootNodeId")
  private String rootNodeId = null;

  @SerializedName("nodeMap")
  private Map<String, ExecutionNode> nodeMap = null;

  @SerializedName("nodeAdjacencyListMap")
  private Map<String, ExecutionNodeAdjacencyList> nodeAdjacencyListMap = null;

  /**
   * Gets or Sets representationStrategy
   */
  @JsonAdapter(RepresentationStrategyEnum.Adapter.class)
  public enum RepresentationStrategyEnum {
    CAMELCASE("CAMELCASE");

    private String value;

    RepresentationStrategyEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static RepresentationStrategyEnum fromValue(String input) {
      for (RepresentationStrategyEnum b : RepresentationStrategyEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<RepresentationStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RepresentationStrategyEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public RepresentationStrategyEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return RepresentationStrategyEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("representationStrategy")
  private RepresentationStrategyEnum representationStrategy = null;

  public ExecutionGraph rootNodeId(String rootNodeId) {
    this.rootNodeId = rootNodeId;
    return this;
  }

   /**
   * Get rootNodeId
   * @return rootNodeId
  **/
  @Schema(description = "")
  public String getRootNodeId() {
    return rootNodeId;
  }

  public void setRootNodeId(String rootNodeId) {
    this.rootNodeId = rootNodeId;
  }

  public ExecutionGraph nodeMap(Map<String, ExecutionNode> nodeMap) {
    this.nodeMap = nodeMap;
    return this;
  }

  public ExecutionGraph putNodeMapItem(String key, ExecutionNode nodeMapItem) {
    if (this.nodeMap == null) {
      this.nodeMap = new HashMap<String, ExecutionNode>();
    }
    this.nodeMap.put(key, nodeMapItem);
    return this;
  }

   /**
   * Get nodeMap
   * @return nodeMap
  **/
  @Schema(description = "")
  public Map<String, ExecutionNode> getNodeMap() {
    return nodeMap;
  }

  public void setNodeMap(Map<String, ExecutionNode> nodeMap) {
    this.nodeMap = nodeMap;
  }

  public ExecutionGraph nodeAdjacencyListMap(Map<String, ExecutionNodeAdjacencyList> nodeAdjacencyListMap) {
    this.nodeAdjacencyListMap = nodeAdjacencyListMap;
    return this;
  }

  public ExecutionGraph putNodeAdjacencyListMapItem(String key, ExecutionNodeAdjacencyList nodeAdjacencyListMapItem) {
    if (this.nodeAdjacencyListMap == null) {
      this.nodeAdjacencyListMap = new HashMap<String, ExecutionNodeAdjacencyList>();
    }
    this.nodeAdjacencyListMap.put(key, nodeAdjacencyListMapItem);
    return this;
  }

   /**
   * Get nodeAdjacencyListMap
   * @return nodeAdjacencyListMap
  **/
  @Schema(description = "")
  public Map<String, ExecutionNodeAdjacencyList> getNodeAdjacencyListMap() {
    return nodeAdjacencyListMap;
  }

  public void setNodeAdjacencyListMap(Map<String, ExecutionNodeAdjacencyList> nodeAdjacencyListMap) {
    this.nodeAdjacencyListMap = nodeAdjacencyListMap;
  }

  public ExecutionGraph representationStrategy(RepresentationStrategyEnum representationStrategy) {
    this.representationStrategy = representationStrategy;
    return this;
  }

   /**
   * Get representationStrategy
   * @return representationStrategy
  **/
  @Schema(description = "")
  public RepresentationStrategyEnum getRepresentationStrategy() {
    return representationStrategy;
  }

  public void setRepresentationStrategy(RepresentationStrategyEnum representationStrategy) {
    this.representationStrategy = representationStrategy;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExecutionGraph executionGraph = (ExecutionGraph) o;
    return Objects.equals(this.rootNodeId, executionGraph.rootNodeId) &&
        Objects.equals(this.nodeMap, executionGraph.nodeMap) &&
        Objects.equals(this.nodeAdjacencyListMap, executionGraph.nodeAdjacencyListMap) &&
        Objects.equals(this.representationStrategy, executionGraph.representationStrategy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(rootNodeId, nodeMap, nodeAdjacencyListMap, representationStrategy);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExecutionGraph {\n");
    
    sb.append("    rootNodeId: ").append(toIndentedString(rootNodeId)).append("\n");
    sb.append("    nodeMap: ").append(toIndentedString(nodeMap)).append("\n");
    sb.append("    nodeAdjacencyListMap: ").append(toIndentedString(nodeAdjacencyListMap)).append("\n");
    sb.append("    representationStrategy: ").append(toIndentedString(representationStrategy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
